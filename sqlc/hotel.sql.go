// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: hotel.sql

package sqlc

import (
	"context"
)

const findHotelByHotelID = `-- name: FindHotelByHotelID :one
SELECT id, hotel_id, destination_id, name, location, description, images, amenities, booking_conditions, created_at, updated_at
FROM hotels
WHERE hotel_id = $1
`

func (q *Queries) FindHotelByHotelID(ctx context.Context, hotelID string) (*Hotel, error) {
	row := q.db.QueryRow(ctx, findHotelByHotelID, hotelID)
	var i Hotel
	err := row.Scan(
		&i.ID,
		&i.HotelID,
		&i.DestinationID,
		&i.Name,
		&i.Location,
		&i.Description,
		&i.Images,
		&i.Amenities,
		&i.BookingConditions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const findHotelsByDestinationAndHotelIDs = `-- name: FindHotelsByDestinationAndHotelIDs :many
SELECT id, hotel_id, destination_id, name, location, description, images, amenities, booking_conditions, created_at, updated_at
FROM hotels
WHERE destination_id = $1
  AND hotel_id = ANY($2::TEXT[])
`

type FindHotelsByDestinationAndHotelIDsParams struct {
	DestinationID string   `json:"destination_id"`
	HotelIds      []string `json:"hotel_ids"`
}

func (q *Queries) FindHotelsByDestinationAndHotelIDs(ctx context.Context, arg FindHotelsByDestinationAndHotelIDsParams) ([]*Hotel, error) {
	rows, err := q.db.Query(ctx, findHotelsByDestinationAndHotelIDs, arg.DestinationID, arg.HotelIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Hotel
	for rows.Next() {
		var i Hotel
		if err := rows.Scan(
			&i.ID,
			&i.HotelID,
			&i.DestinationID,
			&i.Name,
			&i.Location,
			&i.Description,
			&i.Images,
			&i.Amenities,
			&i.BookingConditions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findHotelsByDestinationID = `-- name: FindHotelsByDestinationID :many
SELECT id, hotel_id, destination_id, name, location, description, images, amenities, booking_conditions, created_at, updated_at
FROM hotels
WHERE destination_id = $1
`

func (q *Queries) FindHotelsByDestinationID(ctx context.Context, destinationID string) ([]*Hotel, error) {
	rows, err := q.db.Query(ctx, findHotelsByDestinationID, destinationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Hotel
	for rows.Next() {
		var i Hotel
		if err := rows.Scan(
			&i.ID,
			&i.HotelID,
			&i.DestinationID,
			&i.Name,
			&i.Location,
			&i.Description,
			&i.Images,
			&i.Amenities,
			&i.BookingConditions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findHotelsByHotelIDs = `-- name: FindHotelsByHotelIDs :many
SELECT id, hotel_id, destination_id, name, location, description, images, amenities, booking_conditions, created_at, updated_at
FROM hotels
WHERE hotel_id = ANY($1::TEXT[])
`

func (q *Queries) FindHotelsByHotelIDs(ctx context.Context, hotelIds []string) ([]*Hotel, error) {
	rows, err := q.db.Query(ctx, findHotelsByHotelIDs, hotelIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Hotel
	for rows.Next() {
		var i Hotel
		if err := rows.Scan(
			&i.ID,
			&i.HotelID,
			&i.DestinationID,
			&i.Name,
			&i.Location,
			&i.Description,
			&i.Images,
			&i.Amenities,
			&i.BookingConditions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
